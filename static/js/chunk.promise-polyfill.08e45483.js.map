{"version":3,"sources":["webpack:///static/js/chunk.promise-polyfill.08e45483.js","webpack:///../~/promise-polyfill/promise.js","webpack:///../~/setimmediate/setImmediate.js","webpack:///../~/timers-browserify/main.js"],"names":["webpackJsonp","586","module","exports","__webpack_require__","setImmediate","root","noop","bind","fn","thisArg","apply","arguments","Promise","this","TypeError","_state","_handled","_value","undefined","_deferreds","doResolve","handle","self","deferred","push","_immediateFn","cb","onFulfilled","onRejected","resolve","reject","promise","ret","e","newValue","then","finale","length","_unhandledRejectionFn","i","len","Handler","done","value","reason","ex","setTimeoutFunc","setTimeout","prototype","prom","all","arr","args","Array","slice","call","res","val","remaining","constructor","race","values","err","console","warn","_setImmediateFn","_setUnhandledRejectionFn","597","global","process","callback","Function","task","tasksByHandle","nextHandle","registerImmediate","clearImmediate","run","runIfPresent","currentlyRunningATask","doc","document","attachTo","Object","getPrototypeOf","toString","nextTick","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","messagePrefix","Math","random","onGlobalMessage","event","source","data","indexOf","addEventListener","attachEvent","MessageChannel","channel","port1","port2","createElement","html","documentElement","script","onreadystatechange","removeChild","appendChild","598","Timeout","id","clearFn","_id","_clearFn","window","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout"],"mappings":"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","file":"static/js/chunk.promise-polyfill.08e45483.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 586:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n  \n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function() {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new (this.constructor)(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    var args = Array.prototype.slice.call(arr);\n\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||\n    function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @deprecated\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    Promise._immediateFn = fn;\n  };\n\n  /**\n   * Change the function to execute on unhandled rejection\n   * @param {function} fn Function to execute on unhandled rejection\n   * @deprecated\n   */\n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    Promise._unhandledRejectionFn = fn;\n  };\n  \n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(598).setImmediate))\n\n/***/ }),\n\n/***/ 597:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59), __webpack_require__(137)))\n\n/***/ }),\n\n/***/ 598:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(597);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/chunk.promise-polyfill.08e45483.js","(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n  \n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function() {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new (this.constructor)(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    var args = Array.prototype.slice.call(arr);\n\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||\n    function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @deprecated\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    Promise._immediateFn = fn;\n  };\n\n  /**\n   * Change the function to execute on unhandled rejection\n   * @param {function} fn Function to execute on unhandled rejection\n   * @deprecated\n   */\n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    Promise._unhandledRejectionFn = fn;\n  };\n  \n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/promise-polyfill/promise.js\n// module id = 586\n// module chunks = 1","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/setimmediate/setImmediate.js\n// module id = 597\n// module chunks = 1","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/timers-browserify/main.js\n// module id = 598\n// module chunks = 1"],"sourceRoot":""}